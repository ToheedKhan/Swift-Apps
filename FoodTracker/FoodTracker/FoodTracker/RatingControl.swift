//
//  RatingControl.swift
//  FoodTracker
//
//  Created by tjk on 5/20/17.
//  Copyright © 2017 Toheed Khan. All rights reserved.
//

import UIKit

/*
 Interface Builder does not know anything about the contents of your rating control. To fix this, you define the control as @IBDesignable. This lets Interface Builder instantiate and draw a copy of your control directly in the canvas. Additionally, now that Interface Builder has a live copy of your control, its layout engine can properly position and size the control.
 
 After rebuild
 
 Open Main.storyboard. Once the build completes, the storyboard shows a live view of your rating control.
 
 
 
 You can also specify properties that can then be set in the Attributes inspector. Add the 
 ***@IBInspectable*** attribute 
 to the desired properties. Interface Builder supports the inspection of basic types (and their corresponding optionals), including: Booleans, numbers, strings, as well as CGRect, CGSize, CGPoint, and UIColor.
 */

@IBDesignable class RatingControl: UIStackView {
    
    //MARK: Properties
    private var ratingButtons = [UIButton]()
    
    var rating = 0
    
    @IBInspectable var starSize: CGSize = CGSize(width: 44.0, height: 44.0) {
        didSet {
            setupButtons()
        }
    }
    
    @IBInspectable var starCount: Int = 5 {
        didSet {
            setupButtons()
        }
    }

    //MARK: Initialization
    override init(frame: CGRect) {
        super.init(frame: frame)
        setupButtons()
    }
    
    required init(coder: NSCoder) {
        super.init(coder: coder)
        setupButtons()
    }
    
    //MARK: Private Methods
    private func setupButtons() {
        
        /*
 NOTE
 Ripping out and replacing all of the buttons is not necessarily the best idea from a performance standpoint. However, the didSet observers should only be called by Interface Builder at design time. When the app is running, the setupButtons() method is only called once, when the control is first loaded from the storyboard. Therefore, there’s no need to create a more-complex solution to update the existing buttons in place.
 */
        
        // clear any existing buttons
        for button in ratingButtons {
            removeArrangedSubview(button)
            button.removeFromSuperview()
        }
        ratingButtons.removeAll()
        
        
        for _ in 0..<starCount {
            /*The underscore (_) represents a wildcard, which you can use when you don’t 
             need to know which iteration of the loop is currently executing.
            */
            
            
            // Create the button
            let button = UIButton()
            button.backgroundColor = UIColor.red
            
            // Add constraints
            button.translatesAutoresizingMaskIntoConstraints = false
            /* NOTE
             This line is not strictly necessary. When you add a view to a stack view, the stack view automatically sets the view’s translatesAutoresizingMaskIntoConstraints property to false. However, when using Auto Layout, it’s a good habit to explicitly disable the autogenerated constraints whenever you programmatically create a view. That way you won’t accidentally forget to disable them when it actually matters.*/
            
            button.heightAnchor.constraint(equalToConstant: starSize.height).isActive = true
            button.widthAnchor.constraint(equalToConstant: starSize.width).isActive = true
            
            // Setup the button action
            button.addTarget(self, action: #selector(RatingControl.ratingButtonTapped(button:)), for: .touchUpInside)
            
            // Add the button to the stack
            addArrangedSubview(button)
            
            // Add the new button to the rating button array
            ratingButtons.append(button)
        }
    }
    
    //MARK: Button Action
    func ratingButtonTapped(button: UIButton) {
        print("Button pressed 👍")
    }
}
